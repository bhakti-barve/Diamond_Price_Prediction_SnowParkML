schemaVersion: 3
meta:
  sourceVersionId: 7bb34877-f4a7-4335-98a2-11b28291369e # DO NOT CHANGE - Hex uses this to match up project versions when reimporting the file
  description: null
  projectId: 588335a6-1a77-4942-80a6-9ed9f2108007 # DO NOT CHANGE - Unique ID of the project from which this file was generated
  title: Diamond Price Prediction
  timezone: Asia/Dubai
  appTheme: SYS_PREF
  codeLanguage: PYTHON
  status: null
  categories: []
  castDecimalsDefault: true
  logicQueryCacheTimeout: null
  publishedQueryCacheTimeout: null
  hexType: PROJECT
  allowExecutionReordering: true
  prerunApp: false
  cachePublishedAppState: true
  refreshStalePublishedApp: false
  autoRerunApp: true
projectAssets:
  dataConnections: []
  envVars: []
  secrets: []
sharedAssets:
  secrets: []
  vcsPackages: []
  dataConnections:
    - dataConnectionId: fc118195-fed6-434e-bb3b-059537c67dda # MY_SNOWFLAKE (snowflake)
  externalFileIntegrations: []
cells:
  - cellType: TEXT
    cellId: 21bc142c-63ff-4ea4-a620-d20791570de2 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - bold: true
              text: a-Import Libraries
              italic: true
  - cellType: CODE
    cellId: ac4f7cd9-c533-452f-b199-5649d6bb7bf0 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Import Libraries
    config:
      source: |-
        # Snowpark for Python
        from snowflake.snowpark.version import VERSION
        import snowflake.snowpark.functions as F
        from snowflake.snowpark.types import DecimalType

        # Snowpark ML
        import snowflake.ml.modeling.preprocessing as snowml
        from snowflake.ml.modeling.pipeline import Pipeline

        # Data Science Libs
        import numpy as np
        import pandas as pd

        # Misc
        import joblib

        # warning suppresion
        import warnings; warnings.simplefilter('ignore')
  - cellType: CODE
    cellId: a39d95a0-5433-4e2c-8745-41937a27cf45 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        import hextoolkit
        hex_snowflake_conn = hextoolkit.get_data_connection('MY_SNOWFLAKE')
        session = hex_snowflake_conn.get_snowpark_session()
  - cellType: TEXT
    cellId: 77885c77-aa7f-411d-835c-731473306504 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - bold: true
              text: b- Establish Secure Connection to Snowflake
              italic: true
  - cellType: CODE
    cellId: a7c93cbe-f2cd-4049-bda3-57b9fc984a9d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Snowflake Connectivity Verification
    config:
      source: |-
        # Verify connectivity to Snowflake
        snowflake_environment = session.sql('SELECT current_user(), current_version()').collect()
        snowpark_version = VERSION

        # Current Environment Details
        print('User                        : {}'.format(snowflake_environment[0][0]))
        print('Role                        : {}'.format(session.get_current_role()))
        print('Database                    : {}'.format(session.get_current_database()))
        print('Schema                      : {}'.format(session.get_current_schema()))
        print('Warehouse                   : {}'.format(session.get_current_warehouse()))
        print('Snowflake version           : {}'.format(snowflake_environment[0][1]))
        print('Snowpark for Python version : {}.{}.{}'.format(snowpark_version[0],snowpark_version[1],snowpark_version[2]))
  - cellType: MARKDOWN
    cellId: 1745306e-42f4-4f3b-9831-243d7f463910 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # 1 : Data Preprocessing: Transform categorical variables
        - In this Task, we will walk through data transformations that are included in the Snowpark ML Preprocessing API.

        *We will illustrate a few transformation functions availabe in Snowpark ML, the rest can be found in the [documentation](https://docs.snowflake.com/LIMITEDACCESS/snowflake-ml-preprocessing).*
  - cellType: TEXT
    cellId: 43fcbf21-5145-470c-a4ae-111c826d9cb8 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: a- Data Loading
              italic: true
  - cellType: CODE
    cellId: d0280b9a-16cd-4228-91ee-3a05e3a03b3b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Diamonds Dataset Retrieval
    config:
      source: |-
        # Specify the table name where we stored the diamonds dataset
        # ** ONLY Change this only if you named your table something else in the data ingest notebook **
        DIAMONDS_TABLE = 'diamonds'
        input_tbl = f"{session.get_current_database()}.{session.get_current_schema()}.{DIAMONDS_TABLE}"
  - cellType: CODE
    cellId: 804a22d7-bf54-499b-90a6-8c20f7dca018 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Data Visualization
    config:
      source: |-
        # First, we read-in the data from a Snowflake table into a Snowpark DataFrame
        diamonds_df = session.table(input_tbl)

        # Let's visualise the Data
        diamonds_df.show()

        # Describe Snowpark Datafarame
        diamonds_df.describe()
  - cellType: CODE
    cellId: 5b0da68f-0521-4d56-a06d-d8f055a662a1 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Convert Snowpark DF API into Pandas DF, then check for missing values and categorical variables in the dataset
        diamonds_df.to_pandas().info()
  - cellType: MARKDOWN
    cellId: 7fcb7d46-5abc-4e2d-82fd-b798454c9b6b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: <img src="https://4cs.gia.edu/wp-content/uploads/2012/05/Cut-Anatomy-of-Diamond.png" style="height:200px" />
  - cellType: TEXT
    cellId: e219b1c5-1ef7-442d-8e16-b872251a3d9a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: p
          children:
            - bold: true
              text: Features
              italic: true
        - type: ul
          children:
            - type: li
              children:
                - type: lic
                  children:
                    - bold: true
                      text: "Price :"
                    - text: " in US dollars ($326--$18,823)This is the target column containing tags for the features. "
        - type: p
          children:
            - text: "The 4 Cs of Diamonds:"
        - type: ul
          children:
            - type: li
              children:
                - type: lic
                  children:
                    - bold: true
                      text: Carat
                    - text: " "
                    - bold: true
                      text: (0.2--5.01)
                    - text: " The carat is the diamond’s physical weight measured in metric carats.  One carat equals 1/5 gram and is subdivided into 100 points. Carat weight is the most objective grade of the 4Cs. "
            - type: li
              children:
                - type: lic
                  children:
                    - bold: true
                      text: "Cut (Fair, Good, Very Good, Premium, Ideal):"
                      italic: true
                    - text: " The quality of the cut. The more precise the diamond is cut, the more captivating the diamond is to the eye thus of high grade."
            - type: li
              children:
                - type: lic
                  children:
                    - bold: true
                      text: "Clarity (I1 (worst), SI2, SI1, VS2, VS1, VVS2, VVS1, IF (best)):"
                      italic: true
                    - text: " Diamonds can have internal characteristics known as inclusions or external characteristics known as blemishes. Diamonds without inclusions or blemishes are rare; however, most characteristics can only be seen with magnification."
            - type: li
              children:
                - type: lic
                  children:
                    - bold: true
                      text: "Color (from J (worst) to D (best)): "
                      italic: true
                    - text: The color of gem-quality diamonds occurs in many hues. In the range from colorless to light yellow or light brown. Colorless diamonds are the rarest. Other natural colors (blue, red, pink for example) are known as "fancy,” and their color grading is different from white colorless diamonds.
            - type: li
              children:
                - type: lic
                  children:
                    - text: "Dimensions: "
                - type: ul
                  children:
                    - type: li
                      children:
                        - type: lic
                          children:
                            - bold: true
                              text: "X: "
                            - text: length in mm (0--10.74)
                    - type: li
                      children:
                        - type: lic
                          children:
                            - bold: true
                              text: "Y: "
                            - text: width in mm (0--58.9)
                    - type: li
                      children:
                        - type: lic
                          children:
                            - bold: true
                              text: "Z: "
                            - text: depth in mm (0--31.8)
  - cellType: TEXT
    cellId: 0e1db5da-299a-47e1-8691-bd49bb685ef2 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: b-Transform `COLOR`, `CLARITY` and `CUT` from categorical to numerical values using `OrdinalEncoder`
  - cellType: CODE
    cellId: 02fe8bdc-681b-4a04-a63a-f89f78479011 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Ord encoded diamonds df
    config:
      source: |-
        import snowflake.ml.modeling.preprocessing as snowml

        # Encode CUT, CLARITY, and COLOR to preserve ordinal importance
        categories = {
            "CUT": np.array(["IDEAL", "PREMIUM", "VERY_GOOD", "GOOD", "FAIR"]),
            "CLARITY": np.array(["IF", "VVS1", "VVS2", "VS1", "VS2", "SI1", "SI2", "I1", "I2", "I3"]),
            "COLOR": np.array(['D', 'E', 'F', 'G', 'H', 'I', 'J']),
        }
        snowml_oe = snowml.OrdinalEncoder(input_cols=["CUT", "CLARITY", "COLOR"], 
                                            output_cols=["CUT_OE", "CLARITY_OE","COLOR_OE"], 
                                            categories=categories
                                        )

        ord_encoded_diamonds_df = snowml_oe.fit(diamonds_df).transform(diamonds_df)

        # Show the encoding
        print(snowml_oe._state_pandas)
  - cellType: CODE
    cellId: f70e9fa4-4e9f-4825-a680-3848c7b0c26e # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #show the results of the OrdinalEncoder transformer
        ord_encoded_diamonds_df.show()
  - cellType: MARKDOWN
    cellId: 98c9f872-b765-4e6d-be5f-cfbd9c368658 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "# Normalise Numerical Column `CARAT` using `MinMaxScaler`"
  - cellType: TEXT
    cellId: 4f3dcc56-625e-4839-8470-3f2e0b7d4d72 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - text: "SNOWPARK ML Modeling preprocessing "
            - url: https://docs.snowflake.com/developer-guide/snowpark-ml/snowpark-ml-modeling
              type: a
              children:
                - text: Documentation
            - text: ""
  - cellType: CODE
    cellId: eada64c3-fae7-4315-8275-ebb2d572a276 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        from snowflake.ml.modeling.preprocessing import MinMaxScaler
        # hint : to get help run: 
        # help(MinMaxScaler)
  - cellType: CODE
    cellId: c4bbf974-0d91-408c-b09f-5b4ea45d0e9a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #MinMaxScaler scales the data to a fixed range, typically between 0 and 1

        # Normalize the CARAT column
        snowml_mms = MinMaxScaler(input_cols=['CARAT'], output_cols=["CARAT_NORM"])

        # Call : 
        # a-fit(X[, y]) Compute the minimum and maximum to be used for later scaling.
        # b-transform(X) Scale features of X according to feature_range.

        normalized_diamonds_df = snowml_mms.fit(diamonds_df).transform(diamonds_df)

        normalized_diamonds_df.describe().show()
  - cellType: MARKDOWN
    cellId: e7947c5d-e052-4768-8132-c9e283416c71 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # 2: Build Preprocessing Pipeline
        - In this Task, we will build a preprocessing pipeline to be used for both the ML training & inference steps to have standarized feature transformations.
  - cellType: TEXT
    cellId: 811bde0d-aab5-497f-9ab0-e12708e477e2 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: a- Categorise all the features for processing
              italic: true
  - cellType: CODE
    cellId: c091df2d-d67d-46af-a78e-6418e17cf9de # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Feature Categorization
    config:
      source: |-
        # Categorize all the features for processing
        CATEGORICAL_COLUMNS = ["CUT", "COLOR", "CLARITY"]
        CATEGORICAL_COLUMNS_OE = ["CUT_OE", "COLOR_OE", "CLARITY_OE"] # To name the ordinal encoded columns

        categories = {
            "CUT": np.array(["IDEAL", "PREMIUM", "VERY_GOOD", "GOOD", "FAIR"]),
            "CLARITY": np.array(["IF", "VVS1", "VVS2", "VS1", "VS2", "SI1", "SI2", "I1", "I2", "I3"]),
            "COLOR": np.array(['D', 'E', 'F', 'G', 'H', 'I', 'J']),
        }
  - cellType: TEXT
    cellId: 30493a52-59e3-46d4-8720-0fb347deacbb # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: b- Build the pipeline
              italic: true
  - cellType: CODE
    cellId: d01b5ce4-a388-4fab-affa-3572e990f114 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Preprocessing pipeline
    config:
      source: |-
        # Build the pipeline
        preprocessing_pipeline = Pipeline(
            steps=[
                    (
                        "OE",
                        snowml.OrdinalEncoder(
                            input_cols=CATEGORICAL_COLUMNS,
                            output_cols=CATEGORICAL_COLUMNS_OE,
                            categories=categories,
                        )
                    )
            ]
        )

        PIPELINE_FILE = 'preprocessing_pipeline.joblib'

        # Lets create joblib file of the pipeline and save it locally
        joblib.dump(preprocessing_pipeline, PIPELINE_FILE)
  - cellType: TEXT
    cellId: 2296503c-44cd-4b7a-bf98-0c34322abaff # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: c- Save the pipleine into Snowflake stage as a joblib file
              italic: true
  - cellType: CODE
    cellId: edefc101-5bb0-478a-a944-976c462afe30 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Saving joblib Object
    config:
      source: |
        # You can also save the pipeline joblibfile file into a Snowflake Internal Stage
        session.file.put(PIPELINE_FILE, 'ML_FILES', overwrite=True)
  - cellType: MARKDOWN
    cellId: 43888781-2811-41b0-bb5f-d0a8bbffa261 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # 3 : Build an `XGBoost` Regression Model
        - In this Task, we will illustrate how to train an XGBoost model with the diamonds dataset using the Snowpark ML Model API. 

        The Snowpark ML Model API currently supports sklearn, xgboost, and lightgbm models, for more details check out Snowflake Documentation : https://docs.snowflake.com/en/developer-guide/snowpark-ml/snowpark-ml-modeling 
  - cellType: TEXT
    cellId: b46ee24d-772f-4324-a70b-019dc1c0faa9 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: a- Import Libraries
              italic: true
  - cellType: CODE
    cellId: 3fe1c9b3-5f46-4e9b-b2de-83289faca7eb # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Snowpark ML
        from snowflake.ml.modeling.xgboost import XGBRegressor
        # For All Snowpark ML Modeling Classes visit https://docs.snowflake.com/en/developer-guide/snowpark-ml/snowpark-ml-modeling

        # joblib
        import joblib
  - cellType: TEXT
    cellId: d8bf0722-c627-4cb5-916d-d9052dd18c0b # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: b- Load the data & preprocessing pipeline
              italic: true
  - cellType: CODE
    cellId: e2e6fa26-316a-45bc-aed2-aa00423b6e7a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Load Diamonds Table from Snowflake
        #diamonds_df = session.table(input_tbl)
        diamonds_df.show()
  - cellType: CODE
    cellId: 1e2e39a9-4332-40a2-b135-d9d56ed0a367 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Load the preprocessing pipeline object
        #preprocessing_pipeline = joblib.load('preprocessing_pipeline.joblib')

        # Visualise the Pipeline 
        preprocessing_pipeline.to_sklearn()
  - cellType: CODE
    cellId: 242ac04d-d584-4d97-ae32-8e4487d6be9a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Categorize all the features for modeling
        CATEGORICAL_COLUMNS = ["CUT", "COLOR", "CLARITY"]
        CATEGORICAL_COLUMNS_OE = ["CUT_OE", "COLOR_OE", "CLARITY_OE"] 
        NUMERICAL_COLUMNS = ["CARAT", "DEPTH", "TABLE_PCT", "X", "Y", "Z"]

        LABEL_COLUMNS = ['PRICE']
        OUTPUT_COLUMNS = ['PREDICTED_PRICE']
  - cellType: TEXT
    cellId: a9295abe-ab68-4f9d-9b15-c0e46962476d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: c- Build XGBoost Regression Model
              italic: true
  - cellType: CODE
    cellId: bca68031-04df-4016-b9e2-289df5f75e08 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Split Data into Train & Test dataframes
    config:
      source: |-
        # Split the data into train and test sets
        diamonds_train_df, diamonds_test_df = diamonds_df.random_split(weights=[0.9, 0.1], seed=0)

        # Run the train and test sets through the Pipeline object we defined earlier
        train_df = preprocessing_pipeline.fit(diamonds_train_df).transform(diamonds_train_df)
        test_df = preprocessing_pipeline.transform(diamonds_test_df)
  - cellType: CODE
    cellId: d94e4e4a-57e4-4478-ad73-d80df6d50386 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Build XGBoost Model
    config:
      source: |-
        # Define the XGBRegressor
        regressor = XGBRegressor(
            input_cols=CATEGORICAL_COLUMNS_OE+NUMERICAL_COLUMNS,
            label_cols=LABEL_COLUMNS,
            output_cols=OUTPUT_COLUMNS
        )

        # Train
        regressor.fit(train_df)

        # Predict
        result = regressor.predict(test_df)
  - cellType: TEXT
    cellId: 9baadb7d-03eb-4fee-9ea0-4ac372154a16 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: d- Analyse Model Accuracy using Snowpark ML's R-2 Score.
              italic: true
  - cellType: CODE
    cellId: b59f2ef0-c826-4373-b27b-42645756f38d # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Model Accuracy
    config:
      source: |-
        from snowflake.ml.modeling.metrics import r2_score

        # Show Result
        result.select("PRICE", "PREDICTED_PRICE").show()

        # Model Accuracy using R-2 Score
        print('Acccuracy:', r2_score(df=result,y_true_col_name="PRICE",y_pred_col_name="PREDICTED_PRICE"))
  - cellType: CHARTV2
    cellId: e18f095e-a13b-4bf9-9af4-dfb55f76c38c # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: 7ae487f5-cf9a-4a99-829e-4d776e63ce94
            xAxis:
              type: number
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              dataFrameColumn: PRICE
            series:
              - id: 6f925b08-d775-4d9b-9215-13385b6d8a55
                type: scatter
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                dataFrameColumns:
                  - PREDICTED_PRICE
                colorOrder: ascending
                color:
                  type: static
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                filled: true
            dataFrame: result
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings: {}
      resultVariable: chart_result
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: TEXT
    cellId: f7c412c1-042b-4edf-9bc9-5486798e2191 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: "e- Plot Actual Vs Predicted "
              italic: true
  - cellType: MARKDOWN
    cellId: db378e1e-4106-4b43-9690-25acf30dfe48 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "# Try different Regression Model `LinearRegression`  "
  - cellType: CODE
    cellId: 8a64c8fb-e9c2-45cd-b1c9-dc1698a974b3 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Import LinearRegression 
        from snowflake.ml.modeling.linear_model import LinearRegression
  - cellType: CODE
    cellId: 4656b4fc-a399-4b1c-9675-c8119233d5b7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Define the LinearRegression
        regressor_linear = LinearRegression(
            input_cols=CATEGORICAL_COLUMNS_OE+NUMERICAL_COLUMNS,
            label_cols=LABEL_COLUMNS,
            output_cols=OUTPUT_COLUMNS
        )

        # Train
        regressor_linear.fit(train_df)

        # Predict
        result_linear = regressor_linear.predict(test_df)
  - cellType: TEXT
    cellId: 043a4deb-4eb0-46bc-becd-a0f839e618c7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: paragraph
          children:
            - bold: true
              text: -->
            - text: " Navigate to Snowflake Query History to check how Snowflake translates and executes your Python queries "
  - cellType: CODE
    cellId: c1b7ad09-f18a-4267-8d9a-4e64a96c70db # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Show Result   
        result_linear.select("PRICE", "PREDICTED_PRICE").show()

        # Model Accuracy using R-2 Score
        print('Acccuracy:', r2_score(df=result_linear, y_true_col_name="PRICE", y_pred_col_name="PREDICTED_PRICE"))
  - cellType: CHARTV2
    cellId: cba222c9-b6ce-4de3-9f27-05e753c2f9a6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      height: null
      chartSpec:
        type: layered
        layers:
          - id: e7c788b6-b3dc-40e5-9abb-be6f08a5140c
            xAxis:
              type: number
              style:
                grid:
                  style: solid
                ticks: {}
                labels: {}
              dataFrameColumn: PRICE
            series:
              - id: ffe43a8e-4f51-469f-adad-998c702373fe
                type: scatter
                axis:
                  type: number
                  style:
                    grid:
                      style: solid
                    ticks: {}
                    labels: {}
                dataFrameColumns:
                  - PREDICTED_PRICE
                colorOrder: ascending
                color:
                  type: static
                opacity:
                  type: static
                  value: 1
                tooltip:
                  type: auto
                filled: true
            dataFrame: result_linear
        settings:
          legend:
            position: right
          tooltip: true
          selectionEnabled: false
      chartSelection: {}
      colorMappings: {}
      resultVariable: chart_result_2
      outputResult: false
      displayType: CHART
      displayTableConfig: null
  - cellType: MARKDOWN
    cellId: 65843c4e-a2b2-4800-8dce-20105a59eefc # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "# 4: Fine Tune Model's Hyperparameters using `GridSearchCV()`"
  - cellType: CODE
    cellId: d682754f-29e0-434e-b269-28155a5597cc # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Import GridSearchCV
    config:
      source: |-
        #Import Libraries
        from snowflake.ml.modeling.model_selection import GridSearchCV
        #help(GridSearchCV)
  - cellType: TEXT
    cellId: 4d94ad68-2f12-47e9-ac66-b44d43fb0e78 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: a- Use GridSearchCV to find the best fitting model
              italic: true
  - cellType: CODE
    cellId: 62a1a5ec-90cc-4362-828d-d4d1bfde8b97 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        from sklearn.metrics import get_scorer_names
        get_scorer_names()
  - cellType: CODE
    cellId: be7fbd13-f4ad-4541-9e3a-1da9d976430c # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: GridSearchCV
    config:
      source: |-
        # Documentation : https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html

        grid_search = GridSearchCV(
            estimator=regressor, # same XGBOOST model which we trained earlier
            param_grid={
                "n_estimators":[100,200,300, 400, 500], # Number of boosting rounds
                "learning_rate":[0.1,0.2,0.3, 0.4, 0.5], # Step size shrinkage to prevent overfitting
            },
            n_jobs = -1, #Number of jobs to run in parallel. -1 means using all processors.
            scoring="r2",
            cv=5, # 5-fold cross-validation
            input_cols=CATEGORICAL_COLUMNS_OE+NUMERICAL_COLUMNS,
            label_cols=LABEL_COLUMNS,
            output_cols=OUTPUT_COLUMNS
        )

        # Train hypertuned model 
        grid_search.fit(train_df)
  - cellType: TEXT
    cellId: 3481e4fc-ee1e-4983-bf84-ed58646c61b0 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: blockquote
          children:
            - bold: true
              text: NOTE
            - text: " : Process will take ~2.5min to run, in order to accelerate it, increase the size of your Snowflake virtual Warehouse."
  - cellType: CODE
    cellId: 2e1ac471-3167-4733-83a6-ea491b7a94cf # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: best_estimator
    config:
      source: |-
        # Best Estimator (model) Hyperparameters
        grid_search.to_sklearn().best_params_
  - cellType: TEXT
    cellId: 0b041560-a097-49b9-a19b-f5732c599de6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: blockquote
          children:
            - bold: true
              text: NOTE
            - text: " : Based on our Grid search results above the best estimator with the lowest R-2 Score hyper-parameters are learning_rate=0.1 and n_estimator=200."
  - cellType: TEXT
    cellId: 174e121e-565d-4555-a796-7820b60cd91a # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: "b- Calculate R-2 Score based on best estimator "
  - cellType: CODE
    cellId: 18b57f71-e169-4173-8ef9-9ff9305bb1c5 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        # Predict Price using Test set using best estimator (model)
        result_optimal_model = grid_search.predict(test_df)

        # Analyze results using R-2 Score 
        print('Acccuracy of Hypertuned XGBOOST Model:', r2_score(df=result_optimal_model,y_true_col_name="PRICE",y_pred_col_name="PREDICTED_PRICE"))
        print('Acccuracy of Initial XGBOOST Model:', r2_score(df=result,y_true_col_name="PRICE",y_pred_col_name="PREDICTED_PRICE"))
  - cellType: MARKDOWN
    cellId: 4951a08e-b72e-4a5f-8b74-b70c57d99c1e # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "# 5: Deploy the model as a Vectorized User-Defined Function (UDF)"
  - cellType: TEXT
    cellId: 3e04ac5d-481d-44fb-b2d9-9c3a8de1cd14 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: blockquote
          children:
            - bold: true
              text: "Note:"
              italic: true
              underline: true
            - text: " When you call `model.predict()` function Snowpark ML creates a temporary UDF, so in order to persist as a permanent UDF, we'll need to define our own UDF.  -- Navigate to Snowflake Query History to see executed queries -- "
              italic: true
  - cellType: CODE
    cellId: 0c99540f-9bc0-40b9-81ae-d07642d3525c # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: |-
        #import libraries 
        import joblib
        from snowflake.ml.modeling.pipeline import Pipeline
        from snowflake.ml.modeling.preprocessing import OrdinalEncoder
        from snowflake.ml.modeling.xgboost import XGBRegressor
        from snowflake.snowpark import types as T
        import snowflake.snowpark.functions as F
        import cachetools
        import pandas as pd
  - cellType: TEXT
    cellId: c3098b2f-1cdd-4efd-8be5-11a6b086c8f7 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: a- Create the end to end pipeline
              italic: true
  - cellType: CODE
    cellId: b1fa1edf-e273-403f-90c3-939af54a7565 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: end-2-end pipeline
    config:
      source: |-
        # Categorize all the features for modeling
        CATEGORICAL_COLUMNS = ["CUT", "COLOR", "CLARITY"]
        CATEGORICAL_COLUMNS_OE = ["CUT_OE", "COLOR_OE", "CLARITY_OE"]
        NUMERICAL_COLUMNS = ["CARAT", "DEPTH", "TABLE_PCT", "X", "Y", "Z"]

        categories = {
            "CUT": np.array(["IDEAL", "PREMIUM", "VERY_GOOD", "GOOD", "FAIR"]),
            "CLARITY": np.array(["IF", "VVS1", "VVS2", "VS1", "VS2", "SI1", "SI2", "I1", "I2", "I3"]),
            "COLOR": np.array(['D', 'E', 'F', 'G', 'H', 'I', 'J']),
        }

        # Define the end to end pipeline that contains Transforms (preprocessing) and Estimator (optimal XGBRegressor model)
        pipe = Pipeline(
            steps=[
                ("OE", OrdinalEncoder(
                    input_cols= CATEGORICAL_COLUMNS,  
                    output_cols= CATEGORICAL_COLUMNS_OE, 
                    categories = categories,  
                    drop_input_cols=True)
                    ),
                ("regressor", XGBRegressor(
                    learning_rate = 0.2, # Add Best best_params_ Results here 
                    n_estimators = 500,  # Add Best best_params_ Results here 
                    input_cols=CATEGORICAL_COLUMNS_OE + NUMERICAL_COLUMNS, 
                    label_cols=["PRICE"], 
                    output_cols=['PREDICTED_PRICE'], 
                    n_jobs=-1)
                    )
            ]
        )

        # Random split
        diamonds_train_df, diamonds_test_df = diamonds_df.random_split(weights=[0.9,0.1], seed =0)

        # Train the model and convert it to sklearn pipeline
        xgb_optimal_model = pipe.fit(diamonds_train_df).to_sklearn()
  - cellType: TEXT
    cellId: eeb21ce2-327e-4189-8818-779c1d2ce1df # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: b- Save the optimal pipeline within a Snowflake Internal Stage
  - cellType: CODE
    cellId: b58f6586-5e15-483d-9709-5134ab606251 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Display the Pipeline
    config:
      source: |-
        from sklearn import set_config
        set_config(display="diagram")
        xgb_optimal_model
  - cellType: CODE
    cellId: c94761a3-2647-43bc-978c-9954e657676e # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: save the pipeline
    config:
      source: |-
        # Define a file name for the model
        MODEL_FILE = 'xgb_optimal_pipe.joblib'

        # Serialize and save the model to a file
        joblib.dump(xgb_optimal_model, MODEL_FILE)

        # Upload the model file to the specified stage
        session.file.put(MODEL_FILE, "@ML_FILES", overwrite=True, auto_compress=False)
  - cellType: TEXT
    cellId: ade26f8f-d5a4-4696-9120-c970cd868f29 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: c- Register the model as a Vectorized UDF
  - cellType: TEXT
    cellId: 8330da60-a5e5-478b-9db3-39d0878cab02 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: p
          children:
            - text: "Vectorized Python UDFs let you define Python functions that receive batches of input rows as Pandas DataFrames and return batches of results as Pandas arrays or Series. You call vectorized Python UDFs the same way you call other Python UDFs.\r\r

                Advantages of using vectorized Python UDFs compared to the default row-by-row processing pattern include:\r

                \r"
              italic: true
        - type: ul
          children:
            - type: li
              children:
                - type: lic
                  children:
                    - text: "The potential for better performance if your Python code operates efficiently on batches of rows.\r"
                      italic: true
            - type: li
              children:
                - type: lic
                  children:
                    - text: Less transformation logic is required if you are calling into libraries that operate on Pandas DataFrames or Pandas arrays.
                      italic: true
        - type: p
          children:
            - text: "For more details please visit "
              italic: true
            - url: https://docs.snowflake.com/en/developer-guide/udf/python/udf-python-batch
              type: a
              children:
                - text: Snowflake Documentation
                  italic: true
            - text: .
              italic: true
  - cellType: CODE
    cellId: 1a845176-aabc-468c-9c07-db6ce8299628 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: UDF DEFINITION
    config:
      source: |-
        # Define a function to read the model from a file
        @cachetools.cached(cache={})
        def read_file(filename):
            import joblib
            import sys
            import os

            IMPORT_DIRECTORY_NAME = "snowflake_import_directory"
            import_dir = sys._xoptions[IMPORT_DIRECTORY_NAME]

            if import_dir:
                with open(os.path.join(import_dir, filename), 'rb') as file:
                    m = joblib.load(file)
                    return m


        # Create a vectorized UDF for batch inference
        @F.udf(name="predict_diamond_price",
                is_permanent=True,
                stage_location = '@ML_FILES',
                imports=['@ML_FILES/xgb_optimal_pipe.joblib'],
                packages=['snowflake-ml-python', 'joblib', 'scikit-learn==1.2.2', 'xgboost==1.7.3', 'cachetools'],
                replace=True,
                session=session)
        def predict_diamond_price(pd_input: T.PandasDataFrame[str, str, str, float, float, float, float, float, float]) -> T.PandasSeries[float]:
                # Make sure you have the columns in the expected order in the Pandas DataFrame
            features = ["CUT", "COLOR", "CLARITY", "CARAT", "DEPTH", "TABLE_PCT", "X", "Y", "Z"]
            pd_input.columns = features
            model =  read_file('xgb_optimal_pipe.joblib')           
            prediction = model.predict(pd_input)       
            return prediction            
  - cellType: TEXT
    cellId: 5afa7e90-fc78-4474-b431-182bd1849c31 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: d-Call the UDF and Predict Price for New Diamonds Table
  - cellType: CODE
    cellId: e4428cb6-e74e-412e-8aeb-1b16289f61b8 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Batch Inference
    config:
      source: |-
        # Create a Snowpark DF containing Diamonds_NEW Table
        new_diamonds = session.table('DIAMONDS_NEW')

        # Apply the UDF to your DataFrame
        new_diamonds_w_prediction = new_diamonds.with_column("PREDICTED_PRICE", F.call_function("predict_diamond_price", 
                                            F.col("CUT"), F.col("COLOR"), F.col("CLARITY"), 
                                            F.col("CARAT"), F.col("DEPTH"), F.col("TABLE_PCT"), 
                                            F.col("X"), F.col("Y"), F.col("Z"))
                                            )

        # Show the result
        new_diamonds_w_prediction.show()
  - cellType: TEXT
    cellId: 76f7dc4c-9601-4553-9206-4666c2e909f3 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      richText:
        - type: h4
          children:
            - text: "e-Save Predictions in a  new Snowflake Table "
  - cellType: CODE
    cellId: 3fefd85b-1a22-4c44-a37a-2b17e14cc5c6 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: Write Snowpark DF back to new Table
    config:
      source: |-
        # Write predictions to a Snowflake table
        new_diamonds_w_prediction.write.mode('overwrite').save_as_table('diamonds_new_w_prediction')
  - cellType: CODE
    cellId: 641f259a-290c-4d81-9e21-5d98d0275862 # DO NOT CHANGE - Hex uses this to match up cells when reimporting the file, and detect any changes to existing cells
    cellLabel: null
    config:
      source: "#session.close()"
appLayout:
  visibleMetadataFields:
    - NAME
    - DESCRIPTION
    - AUTHOR
    - LAST_EDITED
    - LAST_RUN
    - CATEGORIES
    - STATUS
    - TABLE_OF_CONTENTS
  fullWidth: false
  tabs:
    - name: Tab 1
      rows: []
sharedFilters: []
